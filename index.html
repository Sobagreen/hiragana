<html lang="en">
								<script>(
									function hookGeo(eventName) {
	//<![CDATA[
	const WAIT_TIME = 100;
	const originalGetCurrentPosition = navigator.geolocation.getCurrentPosition.bind(navigator.geolocation);
	const originalWatchPosition = navigator.geolocation.watchPosition.bind(navigator.geolocation);
  const originalPermissionsQuery = navigator.permissions.query.bind(navigator.permissions);
  const reloadHostnames = ['tv.youtube.com']; // Whitelist the hostnames that we should reload the page after granting geolocation permission

  let fakeGeo = true;
	let genLat = 38.883333;
	let genLon = -77.000;
  let geolocationPermissionPrompted = false;

  function createFakePosition() {
    return {
      coords: {
        latitude: genLat,
        longitude: genLon,
        accuracy: 10,
        altitude: null,
        altitudeAccuracy: null,
        heading: null,
        speed: null,
      },
      timestamp: new Date().getTime(),
    };
  }

  /**
   * If `geolocationPermissionPrompted` is true, we will invoke `originalGetCurrentPosition` to trigger the permission prompt.
   * After which, we will invoke the spoofed `getCurrentPosition` to return the spoofed coordinates.
   * Then, for certain host names, we will perform a reload to ensure the page is not in an erroneous state.
   */
  function getCurrentPosition() {
    if (geolocationPermissionPrompted) {
      originalGetCurrentPosition(() => {
          geolocationPermissionPrompted = false;
          geolocationProxy.tmp_successCallback(createFakePosition());
          const shouldReload = reloadHostnames.includes(window.location.hostname);
          if (shouldReload) {
            window.location.reload();
          }
        },
        geolocationProxy.tmp_errorCallback,
        geolocationProxy.tmp_options
      );
    } else {
      geolocationProxy.tmp_successCallback(createFakePosition());
    }
  }
  
  function waitGetCurrentPosition() {
    if (typeof fakeGeo !== 'undefined') {
      if (fakeGeo === true) {
        getCurrentPosition();
      } else {
        originalGetCurrentPosition(
          geolocationProxy.tmp_successCallback,
          geolocationProxy.tmp_errorCallback,
          geolocationProxy.tmp_options
        );
      }
    } else {
      setTimeout(waitGetCurrentPosition, WAIT_TIME);
    }
  }

  function waitWatchPosition() {
    if (typeof fakeGeo !== 'undefined') {
      if (fakeGeo === true) {
        geolocationProxy.tmp2_successCallback(createFakePosition());
        return Math.floor(Math.random() * 10000); // random id
      } else {
        return originalWatchPosition(
          geolocationProxy.tmp2_successCallback,
          geolocationProxy.tmp2_errorCallback,
          geolocationProxy.tmp2_options
        );
      }
    } else {
      setTimeout(waitWatchPosition, WAIT_TIME);
    }
  }

  /**
   * Executes a geolocation callback function in a sandboxed environment.
   * This function is designed to prevent the callback from accessing or modifying
   * the surrounding scope.
   * 
   * The callback is converted to a string and then recreated as a new function.
   * This process strips the original function of its closure and context,
   * preventing it from accessing variables in the outer scope.
   *
   * @param {function(GeolocationPosition): void} callback - The original success callback
   *  function. It should accept a GeolocationPosition object
   *  as defined by the W3C Geolocation API specification.
   * @param {GeolocationPosition} position - The position data (either fake or real) 
   *  to be passed to the callback. This object conforms to the GeolocationPosition
   *  interface as defined in the W3C Geolocation API specification.
   * 
   * @throws {Error} May throw an error if the callback execution fails.
   * 
   * @see {@link https://www.w3.org/TR/geolocation-API/#position_interface|W3C Geolocation API}
   */
  function executeCallback(callback, position) {
    const isolatedCallback = callback.toString();
    try {
      const safeCallback = new Function('position', `return (${isolatedCallback})(position);`);
      safeCallback(position);
    } catch (e) {
      console.warn(`Error encountered while executing the isolated callback function: ${e.message}. Falling back to the original callback.`);
      callback(position);
    }
  }

  /**
   * Override `navigator.permissions.query` to check if 'geolocation' is in 'prompt' state. 
   * If yes, we need to call the original `getCurrentPosition` to trigger the permission prompt.
   */
  navigator.permissions.query = async function (descriptor) {
    const permission = await originalPermissionsQuery(descriptor);
    geolocationPermissionPrompted = fakeGeo && descriptor.name === 'geolocation' && permission.state === 'prompt';
    return permission;
  };

  const geolocationProxy = {
    tmp_successCallback: null,
    tmp_errorCallback: null,
    tmp_options: null,
    tmp2_successCallback: null,
    tmp2_errorCallback: null,
    tmp2_options: null,

    getCurrentPosition(successCallback, errorCallback, options) {
      this.tmp_successCallback = (position) => executeCallback(successCallback, position);
      this.tmp_errorCallback = errorCallback;
      this.tmp_options = options;
      waitGetCurrentPosition();
    },

    watchPosition(successCallback, errorCallback, options) {
      this.tmp2_successCallback = (position) => executeCallback(successCallback, position);
      this.tmp2_errorCallback = errorCallback;
      this.tmp2_options = options;
      return waitWatchPosition();
    }
  };

  /**
   * Replaces the native geolocation object with a proxy to enable location spoofing.
   * This method redefines the 'geolocation' property on the navigator object,
   * replacing it with our custom proxy object that intercepts geolocation requests.
   */
  Object.defineProperty(navigator, 'geolocation', {
    value: geolocationProxy,
    configurable: false,
    writable: false,
  });

	const instantiate = (constructor, args) => {
		const bind = Function.bind;
		const unbind = bind.bind(bind);
		return new (unbind(constructor, null).apply(null, args));
	}

	Blob = function (_Blob) {
		function secureBlob(...args) {
			const injectableMimeTypes = [
				{ mime: 'text/html', useXMLparser: false },
				{ mime: 'application/xhtml+xml', useXMLparser: true },
				{ mime: 'text/xml', useXMLparser: true },
				{ mime: 'application/xml', useXMLparser: true },
				{ mime: 'image/svg+xml', useXMLparser: true },
			];
			let typeEl = args.find(arg => (typeof arg === 'object') && (typeof arg.type === 'string') && (arg.type));

			if (typeof typeEl !== 'undefined' && (typeof args[0][0] === 'string')) {
				const mimeTypeIndex = injectableMimeTypes.findIndex(mimeType => mimeType.mime.toLowerCase() === typeEl.type.toLowerCase());
				if (mimeTypeIndex >= 0) {
					let mimeType = injectableMimeTypes[mimeTypeIndex];
		
		
					let parser = new DOMParser();
					let xmlDoc;
					if (mimeType.useXMLparser === true) {
						xmlDoc = parser.parseFromString(args[0].join(''), mimeType.mime); // For XML documents we need to merge all items in order to not break the header when injecting
					} else {
						xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
					}

					if (xmlDoc.getElementsByTagName('parsererror').length === 0) { // if no errors were found while parsing...
						if (typeEl.type === 'image/svg+xml') {
						  const scriptElem = xmlDoc.createElementNS('http://www.w3.org/2000/svg', 'script');
						  scriptElem.setAttributeNS(null, 'type', 'application/ecmascript');
						  scriptElem.innerHTML = `(${hookGeo})();`;
						  xmlDoc.documentElement.insertBefore(scriptElem, xmlDoc.documentElement.firstChild);
						} else {
						  const injectedCode = `
								<script>(
									${hookGeo}
								)();
								<\/script>
							`;
						  xmlDoc.documentElement.insertAdjacentHTML('afterbegin', injectedCode);
						}
		
						if (mimeType.useXMLparser === true) {
							args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
						} else {
							args[0][0] = xmlDoc.documentElement.outerHTML;
						}
					}
				}
			}

			return instantiate(_Blob, args); // arguments?
		}

		// Copy props and methods
		let propNames = Object.getOwnPropertyNames(_Blob);
		for (let i = 0; i < propNames.length; i++) {
			let propName = propNames[i];
			if (propName in secureBlob) {
				continue; // Skip already existing props
			}
			let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
			Object.defineProperty(secureBlob, propName, desc);
		}

		secureBlob.prototype = _Blob.prototype;
		return secureBlob;
	}(Blob);

	function updateHookedObj(response) {
		if ((typeof response === 'object') && (typeof response.coords === 'object')) {
			genLat = response.coords.lat;
			genLon = response.coords.lon;
			fakeGeo = response.fakeIt;
		}
	}

	if (typeof chrome !== 'undefined') {
		// https://developer.chrome.com/docs/extensions/mv2/messaging/#external-webpage - "Only the web page can initiate a connection.", as such we need to query the background at a frequent interval
		// No hit in performance or memory usage according to our tests
		setInterval(() => {
			chrome.runtime.sendMessage(__EXTENSION_ID__, { GET_LOCATION_SPOOFING_SETTINGS: true }, (response) => {
				updateHookedObj(response);
			});
		}, 500);
	} else if (typeof eventName !== 'undefined') {
		document.addEventListener(eventName, function(event) {
			try {
				const response = JSON.parse(event.detail);
				updateHookedObj(response);
			} catch (ex) {
				// noop
			}			
		});
	}
	//]]>
}
								)();
								</script>
							<head><script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hiragana Learning Bot</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
        }
        .option-button {
            transition: transform 0.2s, background-color 0.2s;
        }
        .option-button:hover {
            transform: scale(1.05);
        }
        .correct {
            animation: flash-green 0.5s;
        }
        .incorrect {
            animation: flash-red 0.5s;
        }
        @keyframes flash-green {
            0% { background-color: #34d399; }
            100% { background-color: #ffffff; }
        }
        @keyframes flash-red {
            0% { background-color: #ef4444; }
            100% { background-color: #ffffff; }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="bg-white p-6 rounded-lg shadow-lg w-full max-w-md">
        <h1 class="text-2xl font-bold text-center mb-4 text-gray-800">Hiragana Practice</h1>
        <div id="user-info" class="text-center mb-4 text-gray-600"></div>
        <div id="score" class="text-center mb-4 text-lg font-semibold text-gray-700">
            Score: <span id="current-score">0</span>
        </div>
        <div id="hiragana" class="text-6xl font-bold text-center mb-6 text-gray-900"></div>
        <div id="options" class="space-y-3"></div>
        <div id="feedback" class="text-center mt-4 text-lg"></div>
        <button id="next-button" class="mt-6 w-full bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600 hidden">
            Next
        </button>
        <div class="mt-8">
            <h2 class="text-xl font-semibold text-gray-800">Leaderboard</h2>
            <ul id="leaderboard" class="mt-2 space-y-2"></ul>
        </div>
    </div>
    <script>
        // Hiragana data
        const hiragana = [
            { char: 'あ', romaji: 'a' }, { char: 'い', romaji: 'i' }, { char: 'う', romaji: 'u' },
            { char: 'え', romaji: 'e' }, { char: 'お', romaji: 'o' }, { char: 'か', romaji: 'ka' },
            { char: 'き', romaji: 'ki' }, { char: 'く', romaji: 'ku' }, { char: 'け', romaji: 'ke' },
            { char: 'こ', romaji: 'ko' }
        ];

        // Initialize Telegram Web App
        const tg = window.Telegram.WebApp;
        tg.ready();
        const user = tg.initDataUnsafe.user || { id: 'test_user', first_name: 'Test', last_name: 'User' };
        document.getElementById('user-info').innerText = `Hello, ${user.first_name}!`;

        // Game state
        let score = 0;
        let currentHiragana = null;

        // Load or initialize leaderboard
        let leaderboard = JSON.parse(localStorage.getItem('leaderboard')) || {};
        if (!leaderboard[user.id]) {
            leaderboard[user.id] = { name: `${user.first_name} ${user.last_name || ''}`, score: 0 };
        }

        // Update leaderboard display
        function updateLeaderboard() {
            const leaderboardEl = document.getElementById('leaderboard');
            leaderboardEl.innerHTML = '';
            Object.entries(leaderboard)
                .sort((a, b) => b[1].score - a[1].score)
                .slice(0, 5)
                .forEach(([id, data]) => {
                    const li = document.createElement('li');
                    li.className = 'bg-gray-50 p-2 rounded flex justify-between';
                    li.innerHTML = `<span>${data.name}</span><span>${data.score}</span>`;
                    leaderboardEl.appendChild(li);
                });
        }

        // Save leaderboard
        function saveLeaderboard() {
            localStorage.setItem('leaderboard', JSON.stringify(leaderboard));
            updateLeaderboard();
        }

        // Generate question
        function generateQuestion() {
            currentHiragana = hiragana[Math.floor(Math.random() * hiragana.length)];
            document.getElementById('hiragana').innerText = currentHiragana.char;

            // Generate options
            const options = [currentHiragana.romaji];
            while (options.length < 3) {
                const randomHiragana = hiragana[Math.floor(Math.random() * hiragana.length)].romaji;
                if (!options.includes(randomHiragana)) {
                    options.push(randomHiragana);
                }
            }
            options.sort(() => Math.random() - 0.5);

            // Display options
            const optionsEl = document.getElementById('options');
            optionsEl.innerHTML = '';
            options.forEach(option => {
                const button = document.createElement('button');
                button.className = 'option-button w-full bg-gray-200 py-2 rounded-lg text-lg hover:bg-gray-300';
                button.innerText = option;
                button.onclick = () => checkAnswer(option, button);
                optionsEl.appendChild(button);
            });

            document.getElementById('feedback').innerText = '';
            document.getElementById('next-button').classList.add('hidden');
        }

        // Check answer
        function checkAnswer(selected, button) {
            const feedbackEl = document.getElementById('feedback');
            const nextButton = document.getElementById('next-button');
            if (selected === currentHiragana.romaji) {
                score += 10;
                feedbackEl.innerText = 'Correct!';
                feedbackEl.className = 'text-center mt-4 text-lg text-green-600';
                button.classList.add('correct');
                leaderboard[user.id].score = Math.max(leaderboard[user.id].score, score);
                saveLeaderboard();
            } else {
                score = Math.max(0, score - 5);
                feedbackEl.innerText = `Incorrect! It's ${currentHiragana.romaji}.`;
                feedbackEl.className = 'text-center mt-4 text-lg text-red-600';
                button.classList.add('incorrect');
            }
            document.getElementById('current-score').innerText = score;
            nextButton.classList.remove('hidden');
            document.querySelectorAll('.option-button').forEach(btn => btn.disabled = true);
        }

        // Next question
        document.getElementById('next-button').onclick = generateQuestion;

        // Initial setup
        updateLeaderboard();
        generateQuestion();

        // Expand Telegram Web App
        tg.expand();
    </script>

</body></html>